from flask import Flask, request, render_template, jsonify
import joblib
import os
import time
import traceback
from feature_extraction import extract_features, print_feature_summary, get_expected_feature_names
import numpy as np
import pandas as pd

app = Flask(__name__)

# Load the trained model (latest V2 model)
try:
    model_path = 'malwareclassifier-V2.pkl'
    model = joblib.load(model_path)
    
    # Get model file timestamp for verification
    import os
    model_stat = os.stat(model_path)
    model_created = time.ctime(model_stat.st_mtime)
    model_size = model_stat.st_size
    
    print("✅ ML model loaded successfully")
    print(f"   Model file: {model_path}")
    print(f"   File size: {model_size:,} bytes")
    print(f"   Last modified: {model_created}")
    print("   This is the LATEST retrained model (Sept 5, 2025)")
except Exception as e:
    print(f"❌ Failed to load ML model: {e}")
    model = None

# Load training feature distributions from JSON file
try:
    import json
    with open('training_feature_distributions.json', 'r') as f:
        training_feature_distributions = json.load(f)
    print("✅ Training feature distributions loaded successfully (JSON)")
except Exception as e:
    print(f"❌ Failed to load training feature distributions: {e}")
    training_feature_distributions = None

UPLOAD_FOLDER = 'uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
ALLOWED_EXTENSIONS = {'dll', 'exe'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def get_file_info(file_path):
    """Get basic file information"""
    try:
        stat = os.stat(file_path)
        return {
            'size': stat.st_size,
            'created': time.ctime(stat.st_ctime),
            'modified': time.ctime(stat.st_mtime)
        }
    except:
        return {'size': 0, 'created': 'Unknown', 'modified': 'Unknown'}

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/analyze', methods=['POST'])
def analyze():
    start_time = time.time()
    
    # Initialize result structure
    result = {
        "type": "file",
        "prediction": "Error",
        "confidence": 0.0,
        "file_name": "",
        "file_size": 0,
        "analysis_time": 0.0,
        "features_extracted": 0,
        "error": None,
        "file_info": {}
    }
    
    try:
        # Check if model is loaded
        if model is None:
            result["error"] = "ML model not available. Please check model file."
            return render_template('result.html', result=result)
        
        # Check if a file is uploaded
        if 'file' not in request.files:
            result["error"] = "No file uploaded. Please select a file."
            return render_template('index.html', error="No file uploaded.")
        
        file = request.files['file']
        
        if file.filename == '':
            result["error"] = "No file selected. Please choose a file."
            return render_template('index.html', error="No file selected.")
        
        if not allowed_file(file.filename):
            result["error"] = f"Unsupported file type. Only .exe and .dll files are supported."
            return render_template('index.html', error="Unsupported file type. Only .exe and .dll files are supported.")
        
        # Save the file
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        file.save(file_path)
        
        # Update result with basic file info
        result["file_name"] = file.filename
        result["file_info"] = get_file_info(file_path)
        result["file_size"] = result["file_info"]["size"]
        
        print(f"Analyzing file: {file.filename} ({result['file_size']:,} bytes)")
        
        # Extract features with error handling
        try:
            features = extract_features(file_path)
            
            if features is None:
                result["error"] = "Failed to extract features. The file may not be a valid PE executable or may be corrupted."
                return render_template('result.html', result=result)
            
            if features.empty:
                result["error"] = "No features extracted. The file structure may be invalid."
                return render_template('result.html', result=result)
            
            result["features_extracted"] = len(features.columns)
            print(f"Extracted {result['features_extracted']} features successfully")
            
            # Debug: Print feature order and names
            print("Feature columns order:")
            for i, col in enumerate(features.columns):
                print(f"  {i+1:2d}. {col}")
            
            # Add feature distribution comparison after feature extraction
            if training_feature_distributions is not None:
                try:
                    print("Comparing extracted features with training distributions...")
                    for feature in features.columns:
                        if feature in training_feature_distributions:
                            extracted_mean = features[feature].mean()
                            training_mean = training_feature_distributions[feature]['mean']
                            training_std = training_feature_distributions[feature]['std']
                            print(f"Feature: {feature}")
                            print(f"  Extracted Mean: {extracted_mean:.4f}")
                            print(f"  Training Mean: {training_mean:.4f}")
                            print(f"  Training Std: {training_std:.4f}")
                            print(f"  Difference: {abs(extracted_mean - training_mean):.4f}")
                            # Check if value is within reasonable range (within 3 standard deviations)
                            if abs(extracted_mean - training_mean) > 3 * training_std:
                                print(f"  ⚠️  WARNING: Feature value outside normal range!")
                        else:
                            print(f"Feature {feature} not found in training distributions.")
                except Exception as e:
                    print(f"Error comparing feature distributions: {e}")
            
        except Exception as fe:
            result["error"] = f"Feature extraction failed: {str(fe)}"
            print(f"Feature extraction error for {file.filename}: {fe}")
            return render_template('result.html', result=result)
        
        # Make prediction with error handling
        try:
            # Debug: Check if model has feature_names_in_ attribute
            if hasattr(model, 'feature_names_in_'):
                expected_features = model.feature_names_in_
                print(f"Model expects {len(expected_features)} features:")
                for i, feat in enumerate(expected_features):
                    print(f"  {i+1:2d}. {feat}")
            else:
                print("Model doesn't have feature_names_in_ attribute (older sklearn version)")
            
            # Make prediction
            prediction = model.predict(features)
            prediction_proba = model.predict_proba(features)
            
            # Adjust confidence threshold for classification
            confidence_threshold = 0.6  # Example threshold
            
            if prediction_proba[0].max() >= confidence_threshold:
                result["prediction"] = "Malware" if prediction[0] == 1 else "Safe"
            else:
                result["prediction"] = "Safe"

            result["confidence"] = float(prediction_proba[0].max())

            # Log feature values for debugging
            print("Feature values used for prediction:")
            print(features)
            
            print(f"Prediction: {result['prediction']} (confidence: {result['confidence']:.2%})")
            
        except Exception as pe:
            print(f"Prediction error details:")
            print(f"  Feature count: {len(features.columns)}")
            print(f"  Feature names: {list(features.columns)}")
            
            # Try to get model feature info
            try:
                if hasattr(model, 'n_features_in_'):
                    print(f"  Model expects {model.n_features_in_} features")
                if hasattr(model, 'feature_names_in_'):
                    print(f"  Model expected names: {list(model.feature_names_in_)}")
            except:
                pass
                
            result["error"] = f"Model prediction failed: {str(pe)}"
            print(f"Prediction error for {file.filename}: {pe}")
            return render_template('result.html', result=result)
        
        # Calculate analysis time
        result["analysis_time"] = round(time.time() - start_time, 2)
        
        # Clean up uploaded file
        try:
            os.remove(file_path)
        except:
            pass
        
        print(f"Analysis completed in {result['analysis_time']}s")
        return render_template('result.html', result=result)
        
    except Exception as e:
        result["error"] = f"Unexpected error during analysis: {str(e)}"
        result["analysis_time"] = round(time.time() - start_time, 2)
        
        print(f"Unexpected error analyzing {file.filename if 'file' in locals() else 'unknown file'}: {e}")
        print(f"Traceback: {traceback.format_exc()}")
        
        return render_template('result.html', result=result)

@app.route('/health')
def health_check():
    """Health check endpoint"""
    return jsonify({
        "status": "healthy" if model is not None else "unhealthy",
        "model_loaded": model is not None,
        "upload_folder": os.path.exists(UPLOAD_FOLDER)
    })

if __name__ == '__main__':
    print("=== ML-Based Malware Detection Server ===")
    print(f"Upload folder: {os.path.abspath(UPLOAD_FOLDER)}")
    print(f"Supported file types: {', '.join(ALLOWED_EXTENSIONS)}")
    print("Starting server on http://localhost:5001")
    print("Health check available at: http://localhost:5001/health")
    
    app.run(port=5001, debug=True)

