import pefile
import pandas as pd
import math
import os

# Function to calculate entropy of a section
def calculate_entropy(data):
    """Calculate entropy of data - higher entropy may indicate packed/encrypted content"""
    if not data or len(data) == 0:
        return 0
    
    entropy = 0
    for x in range(256):
        p_x = float(data.count(bytes([x]))) / len(data)
        if p_x > 0:
            entropy += - p_x * math.log(p_x, 2)
    return entropy

def validate_pe_file(file_path):
    """Validate that the file is a proper PE file"""
    try:
        if not os.path.exists(file_path):
            print(f"File does not exist: {file_path}")
            return False
        
        file_size = os.path.getsize(file_path)
        if file_size < 64:  # Minimum PE file size
            print(f"File too small to be a valid PE: {file_size} bytes")
            return False
        
        # Check DOS header
        with open(file_path, 'rb') as f:
            dos_header = f.read(2)
            if dos_header != b'MZ':
                print("Invalid DOS header - not a PE file")
                return False
        
        return True
    except Exception as e:
        print(f"Error validating PE file: {e}")
        return False

def safe_get_attribute(obj, attr_path, default=0):
    """Safely get nested attributes with default fallback"""
    try:
        attrs = attr_path.split('.')
        result = obj
        for attr in attrs:
            result = getattr(result, attr)
        return result
    except (AttributeError, TypeError):
        return default

def extract_features(file_path):
    """Extract features from PE file with comprehensive error handling"""
    try:
        print(f"Starting feature extraction for: {file_path}")
        
        # Validate file first
        if not validate_pe_file(file_path):
            print("PE file validation failed")
            return None
        
        # Load PE file
        try:
            pe = pefile.PE(file_path, fast_load=True)
        except pefile.PEFormatError as e:
            print(f"PE format error: {e}")
            return None
        except Exception as e:
            print(f"Error loading PE file: {e}")
            return None
        
        # Extract features in the EXACT ORDER the model was trained on
        # This order comes from the training notebook: malware_ditaction_insa_1.ipynb
        features = {}
        
        try:
            # Extract features in the EXACT ORDER the model was trained on
            # This order comes from the training feature distributions JSON file
            features = {}
            
            # EXACT 22 FEATURES that the model expects (in alphabetical order as stored in model)
            features['MajorLinkerVersion'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.MajorLinkerVersion', 0)
            features['MajorSubsystemVersion'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.MajorSubsystemVersion', 0)
            features['MinorOperatingSystemVersion'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.MinorOperatingSystemVersion', 0)
            features['SizeOfStackReserve'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.SizeOfStackReserve', 0)
            features['TimeDateStamp'] = safe_get_attribute(pe, 'FILE_HEADER.TimeDateStamp', 0)
            features['MinorImageVersion'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.MinorImageVersion', 0)
            features['Characteristics'] = safe_get_attribute(pe, 'FILE_HEADER.Characteristics', 0)
            features['ImageBase'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.ImageBase', 0)
            features['MajorOperatingSystemVersion'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.MajorOperatingSystemVersion', 0)
            features['Subsystem'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.Subsystem', 0)
            features['DirectoryEntryExport'] = 1 if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT') else 0
            features['MinorSubsystemVersion'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.MinorSubsystemVersion', 0)
            features['SizeOfInitializedData'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.SizeOfInitializedData', 0)
            features['DllCharacteristics'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.DllCharacteristics', 0)
            features['MajorImageVersion'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.MajorImageVersion', 0)
            features['SectionMinVirtualsize'] = 0  # Will calculate below
            features['SizeOfHeaders'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.SizeOfHeaders', 0)
            features['SectionMaxChar'] = len(pe.sections) if pe.sections else 0
            features['ImageDirectoryEntryExport'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[0].Size if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT') and len(pe.OPTIONAL_HEADER.DATA_DIRECTORY) > 0 else 0
            features['CheckSum'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.CheckSum', 0)
            features['SizeOfImage'] = safe_get_attribute(pe, 'OPTIONAL_HEADER.SizeOfImage', 0)
            features['DirectoryEntryImportSize'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[1].Size if len(pe.OPTIONAL_HEADER.DATA_DIRECTORY) > 1 else 0
            
            # Calculate section-based features (only SectionMinVirtualsize)
            virtual_sizes = []
            
            if pe.sections:
                for section in pe.sections:
                    try:
                        # Get virtual size only
                        virtual_size = getattr(section, 'Misc_VirtualSize', 0)
                        if virtual_size > 0:
                            virtual_sizes.append(virtual_size)
                            
                    except Exception as e:
                        print(f"Error processing section: {e}")
                        continue
            
            # Update section feature
            features['SectionMinVirtualsize'] = min(virtual_sizes) if virtual_sizes else 0
            
            print(f"Successfully extracted {len(features)} features")
            
            # Validate that we have exactly 22 features
            expected_features = 22
            if len(features) != expected_features:
                print(f"ERROR: Expected {expected_features} features, got {len(features)}")
                print("Features extracted:", list(features.keys()))
                return None
            
            # Debug: Log the extracted features
            print("Extracted features:", features)

            # Feature order that matches the model's expectation
            feature_order = [
                'MajorLinkerVersion',
                'MajorSubsystemVersion', 
                'MinorOperatingSystemVersion',
                'SizeOfStackReserve',
                'TimeDateStamp',
                'MinorImageVersion',
                'Characteristics',
                'ImageBase',
                'MajorOperatingSystemVersion',
                'Subsystem',
                'DirectoryEntryExport',
                'MinorSubsystemVersion',
                'SizeOfInitializedData',
                'DllCharacteristics',
                'MajorImageVersion',
                'SectionMinVirtualsize',
                'SizeOfHeaders',
                'SectionMaxChar',
                'ImageDirectoryEntryExport',
                'CheckSum',
                'SizeOfImage',
                'DirectoryEntryImportSize'
            ]
            
            # Create ordered feature list
            ordered_features = []
            for col in feature_order:
                if col in features:
                    ordered_features.append(features[col])
                else:
                    print(f"ERROR: Missing feature {col}")
                    return None

            # Debug: Log the ordered features before DataFrame creation
            print("Ordered features:", ordered_features)

            # Create DataFrame with exact column order
            df = pd.DataFrame([ordered_features], columns=feature_order)

            # Debug: Log the resulting DataFrame
            print("Resulting DataFrame:\n", df)

            # Validate DataFrame
            if df.empty or df.isnull().all().all():
                print("Generated DataFrame is empty or all null")
                return None

            print("Feature extraction completed successfully")
            return df
            
        except Exception as e:
            print(f"Error extracting features: {e}")
            return None
            
    except Exception as e:
        print(f"Unexpected error in feature extraction: {e}")
        return None
    
    finally:
        # Clean up PE object
        try:
            if 'pe' in locals():
                pe.close()
        except:
            pass

def print_feature_summary(features_df):
    """Print a summary of extracted features for debugging"""
    if features_df is None or features_df.empty:
        print("No features to summarize")
        return
    
    print(f"\n=== Feature Extraction Summary ===")
    print(f"Features extracted: {len(features_df.columns)}")
    print(f"Null values: {features_df.isnull().sum().sum()}")
    
    # Show all feature names in order
    print("\nAll feature names (in order):")
    for i, col in enumerate(features_df.columns):
        print(f"  {i+1:2d}. {col}: {features_df[col].iloc[0]}")
    
    print("=" * 50)

def get_expected_feature_names():
    """Return the exact feature names in the order the model expects (22 features)"""
    return [
        'MajorLinkerVersion',
        'MajorSubsystemVersion', 
        'MinorOperatingSystemVersion',
        'SizeOfStackReserve',
        'TimeDateStamp',
        'MinorImageVersion',
        'Characteristics',
        'ImageBase',
        'MajorOperatingSystemVersion',
        'Subsystem',
        'DirectoryEntryExport',
        'MinorSubsystemVersion',
        'SizeOfInitializedData',
        'DllCharacteristics',
        'MajorImageVersion',
        'SectionMinVirtualsize',
        'SizeOfHeaders',
        'SectionMaxChar',
        'ImageDirectoryEntryExport',
        'CheckSum',
        'SizeOfImage',
        'DirectoryEntryImportSize'
    ]
