#!/usr/bin/env python3
"""
Alternative EXE Creator for ML Testing
Uses different methods to create test executables without PyInstaller conflicts
"""

import os
import shutil
import subprocess
import sys

def copy_system_executables():
    """Copy legitimate system executables as test samples"""
    
    output_dir = "test_executables_system"
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    print("=== Copying System Executables for Testing ===")
    
    # Safe system executables to copy
    system_files = [
        ("C:\\Windows\\System32\\notepad.exe", "safe_notepad.exe"),
        ("C:\\Windows\\System32\\calc.exe", "safe_calculator.exe"), 
        ("C:\\Windows\\System32\\ping.exe", "safe_network_tool.exe"),
        ("C:\\Windows\\System32\\tasklist.exe", "safe_process_viewer.exe"),
        ("C:\\Windows\\System32\\systeminfo.exe", "safe_system_info.exe")
    ]
    
    copied_files = []
    
    for source, target in system_files:
        if os.path.exists(source):
            target_path = os.path.join(output_dir, target)
            try:
                shutil.copy2(source, target_path)
                file_size = os.path.getsize(target_path)
                print(f"‚úÖ Copied: {target} ({file_size:,} bytes)")
                copied_files.append(target)
            except Exception as e:
                print(f"‚ùå Failed to copy {source}: {e}")
        else:
            print(f"‚ö†Ô∏è  Not found: {source}")
    
    print(f"\nüìÅ System executables copied to: {output_dir}/")
    return copied_files

def create_compiled_c_executables():
    """Create simple C programs and compile them to .exe"""
    
    output_dir = "test_executables_compiled"
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    print("\n=== Creating Compiled C Executables ===")
    
    # Simple C programs
    c_programs = {
        "safe_hello.c": '''
#include <stdio.h>
#include <stdlib.h>

int main() {
    printf("Hello! This is a safe test program.\\n");
    printf("This executable is for testing malware detection.\\n");
    printf("Press any key to continue...\\n");
    getchar();
    return 0;
}
''',
        "suspicious_network.c": '''
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    printf("Network Scanner v1.0\\n");
    printf("Scanning network for vulnerabilities...\\n");
    
    // Simulate suspicious network activity
    char* suspicious_ips[] = {
        "192.168.1.1", "10.0.0.1", "172.16.0.1", 
        "malware-c2.badactor.com", "evil-server.com"
    };
    
    for(int i = 0; i < 5; i++) {
        printf("Attempting connection to: %s\\n", suspicious_ips[i]);
        // Simulate delay
        for(volatile int j = 0; j < 100000000; j++);
    }
    
    printf("Network scan complete.\\n");
    printf("This is a test program for malware detection.\\n");
    getchar();
    return 0;
}
''',
        "malware_simulator.c": '''
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    printf("Malware Behavior Simulator\\n");
    printf("WARNING: This simulates malicious behavior!\\n");
    
    // Simulate malware-like strings
    char* malware_strings[] = {
        "keylogger", "backdoor", "trojan", "ransomware",
        "steal_passwords", "encrypt_files", "disable_antivirus"
    };
    
    printf("Initializing malicious modules:\\n");
    for(int i = 0; i < 7; i++) {
        printf("- Loading: %s\\n", malware_strings[i]);
        // Simulate processing time
        for(volatile int j = 0; j < 50000000; j++);
    }
    
    printf("Malware simulation complete (this is just a test!)\\n");
    getchar();
    return 0;
}
'''
    }
    
    compiled_files = []
    
    # Check if GCC is available
    try:
        result = subprocess.run(["gcc", "--version"], capture_output=True, text=True)
        if result.returncode != 0:
            print("‚ùå GCC compiler not found. Skipping C compilation.")
            return compiled_files
        print(f"‚úÖ GCC compiler found")
    except FileNotFoundError:
        print("‚ùå GCC compiler not available. Skipping C compilation.")
        return compiled_files
    
    for filename, code in c_programs.items():
        try:
            # Write C source file
            c_path = os.path.join(output_dir, filename)
            with open(c_path, 'w') as f:
                f.write(code)
            
            # Compile to .exe
            exe_name = filename.replace('.c', '.exe')
            exe_path = os.path.join(output_dir, exe_name)
            
            compile_cmd = ["gcc", c_path, "-o", exe_path]
            result = subprocess.run(compile_cmd, capture_output=True, text=True)
            
            if result.returncode == 0 and os.path.exists(exe_path):
                file_size = os.path.getsize(exe_path)
                print(f"‚úÖ Compiled: {exe_name} ({file_size:,} bytes)")
                compiled_files.append(exe_name)
                
                # Clean up source file
                os.remove(c_path)
            else:
                print(f"‚ùå Failed to compile {filename}: {result.stderr}")
                
        except Exception as e:
            print(f"‚ùå Error creating {filename}: {e}")
    
    if compiled_files:
        print(f"\nüìÅ Compiled executables created in: {output_dir}/")
    
    return compiled_files

def download_test_executables():
    """Create some simple test executables using alternative methods"""
    
    output_dir = "test_executables_misc"
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    print("\n=== Creating Miscellaneous Test Files ===")
    
    created_files = []
    
    try:
        # Create a simple .com file (DOS executable)
        com_content = bytes([
            0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8,
            0x01, 0x4C, 0xCD, 0x21, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20,
            0x57, 0x6F, 0x72, 0x6C, 0x64, 0x21, 0x0D, 0x0A, 0x24
        ])
        
        com_path = os.path.join(output_dir, "simple_test.com")
        with open(com_path, 'wb') as f:
            f.write(com_content)
        
        print(f"‚úÖ Created: simple_test.com ({len(com_content)} bytes)")
        created_files.append("simple_test.com")
        
    except Exception as e:
        print(f"‚ùå Failed to create .com file: {e}")
    
    # Create fake PE headers for testing (minimal PE structure)
    try:
        # Minimal PE file structure
        pe_content = bytearray(1024)  # 1KB file
        
        # DOS header
        pe_content[0:2] = b'MZ'  # DOS signature
        pe_content[60:64] = (128).to_bytes(4, 'little')  # PE header offset
        
        # PE header
        pe_content[128:132] = b'PE\x00\x00'  # PE signature
        pe_content[132:134] = (0x014c).to_bytes(2, 'little')  # Machine type (i386)
        pe_content[134:136] = (1).to_bytes(2, 'little')  # Number of sections
        
        fake_pe_path = os.path.join(output_dir, "minimal_pe_test.exe")
        with open(fake_pe_path, 'wb') as f:
            f.write(pe_content)
        
        print(f"‚úÖ Created: minimal_pe_test.exe ({len(pe_content)} bytes)")
        created_files.append("minimal_pe_test.exe")
        
    except Exception as e:
        print(f"‚ùå Failed to create minimal PE: {e}")
    
    if created_files:
        print(f"\nüìÅ Miscellaneous test files created in: {output_dir}/")
    
    return created_files

def main():
    print("=== Alternative EXE Creator for ML Testing ===")
    print("Creating test executables without PyInstaller...")
    
    all_files = []
    
    # Method 1: Copy system executables
    system_files = copy_system_executables()
    all_files.extend(system_files)
    
    # Method 2: Compile C programs
    compiled_files = create_compiled_c_executables()
    all_files.extend(compiled_files)
    
    # Method 3: Create miscellaneous test files
    misc_files = download_test_executables()
    all_files.extend(misc_files)
    
    print(f"\n" + "="*60)
    print(f"SUMMARY:")
    print(f"‚úÖ Total test files created: {len(all_files)}")
    
    if all_files:
        print(f"\nüéØ Test executables ready for ML detection:")
        for file in all_files:
            print(f"   - {file}")
        
        print(f"\nüìã Next Steps:")
        print(f"1. These files can be uploaded to your ML detection system")
        print(f"2. System executables should be detected as SAFE")
        print(f"3. Files with suspicious names/behavior should trigger detection")
        print(f"4. Test the improved error handling in your ML app")
        
    else:
        print("‚ùå No test files were created successfully")
    
    print(f"\nüöÄ Your improved ML detection system is ready for testing!")

if __name__ == "__main__":
    main()
